/**
 *Submitted for verification at Etherscan.io on 2021-04-06
*/

pragma solidity 0.8.3;

library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b <= a, errorMessage);
        uint256 c = a - b;

        return c;
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b > 0, errorMessage);
        uint256 c = a / b;
        return c;
    }

    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        return mod(a, b, "SafeMath: modulo by zero");
    }

    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {
        require(b != 0, errorMessage);
        return a % b;
    }
}

abstract contract ERC20 {
    function totalSupply() external virtual view returns (uint256);
    function balanceOf(address account) external virtual view returns (uint256);
    function transfer(address recipient, uint256 amount) external virtual returns (bool);
    function allowance(address owner, address spender) external virtual view returns (uint256);
    function approve(address spender, uint256 amount) external virtual returns (bool);
    function transferFrom(address sender, address recipient, uint256 amount) external virtual returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    function getTier(address _user) external virtual view returns (uint256 _tier);
}

// CONTRACT FOR MINTING NEW DGF TOKENS
// Accept (as input) the % of fees generated by different users...

contract Minting {
    using SafeMath for uint256;
    
    address private constant dgfAddress = address(0x0);
    
    ERC20   public token                = ERC20(dgfAddress); // Digifox Token
    bool    public hasAllocated         = false;
    
    address public owner;
    uint256 public totalActualMinted;
    uint256 public totalExtraTokens;
    uint256 private reward;
    uint256 private periodsElapsed;
    uint256 private lastBlockMinted;
    
    uint256 private constant blocksInAMonth     = 195810; // 195810 blocks every 30 days
    uint256 private constant decayMinuend       = 104000000000000000000000;
    uint256 private constant decaySubtrahend    = 2122000000000000000000;
    uint256 private constant decimals           = 18; 
    uint256 private constant maxPeriods         = 49;
    
    mapping(uint256 => uint256) public actualMintedAmount;
    mapping(address => uint256) public generatedRewards;
    mapping(address => bool) public mintingAdmins;
    mapping(address => bool) public isStaking;
    mapping(address => uint256) public stakingPeriod;
    
    
    /***********************  MODIFIERS AND CONSTRUCTOR  ***********************/ 
    
    modifier monthPassed() {
        // Only 49 periods may elapse, and the last block minted must have been a month ago.
        require(block.number >= lastBlockMinted.add(blocksInAMonth) && periodsElapsed <= maxPeriods);
        _;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner may use this function.");
        _;
    }
    
    modifier onlyOwnerOrAdmin() {
        require(msg.sender == owner || mintingAdmins[msg.sender], "Only the owner or admins may use this function.");
        _;
    }
    
    constructor() {
        periodsElapsed = 1;
        lastBlockMinted = 0;
        owner = msg.sender;
    }
    
    /**************************  USER FUNCTIONS  **************************/ 
    /***********************************************************************
        Function:   beginStaking()
        Args:       None
        Returns:    None
        Notes:      Used by a user to take place in the early adopters 
                        program.
    ***********************************************************************/
    
    function beginStaking() public {
        require(!isStaking[msg.sender], "This user is already staking.");
        isStaking[msg.sender] = true;
        if (stakingPeriod[msg.sender] == 0) stakingPeriod[msg.sender] = block.number;
    }
    
    /***********************************************************************
        Function:   redeemAirdrop()
        Args:       None
        Returns:    None
        Notes:      Used to redeem your airdop.
    ***********************************************************************/
    
    function redeemAirdrop() public {
        require(generatedRewards[msg.sender] > 0, "There are no tokens left to redeem.");
        token.transfer(msg.sender, generatedRewards[msg.sender]);
        generatedRewards[msg.sender] = 0;
        stakingPeriod[msg.sender] = block.number;
    }
    
    /**************************  ADMIN FUNCTIONS  **************************/ 
    // Don't forget to add recovery functions for extra tokens //
    
    
    function triggerGiveaway(address[] memory _recipients, uint256[] memory _feesSpent) public onlyOwnerOrAdmin {
        require(_recipients.length == _feesSpent.length, "Array lengths don't match... please check inputs.");
        uint256 feesGeneratedInPeriod;
        address[] memory activeParticipants; 
        
        
        for (uint256 i = 0; i < _recipients.length; i++) {
            // TODO: WRONG, FIX 
            if (isStaking[_recipients[i]]) {
                feesGeneratedInPeriod = feesGeneratedInPeriod.add(_feesSpent[i]);
            }
        }
    }
    
    /***********************************************************************
        Function:   mint()
        Args:       address[] memory _recipients the qualified addresses.
                    uint256[] memory _feesGenerated the reward calculated
                        from bonuses calculated from fees generated on the 
                        Digifox platform. Send to the HUNDRED THOUSANDS for 
                        precision purposes (ie: 25625 = 25.625% fees 
                        from this period).
                    uint256 _rewardMultipler the percent of DGF to mint in
                        proportion to the UPPER BOUND. Send to the HUNDRED 
                        THOUSANDS for precision purposes (ie: 24556 = 24.556%).
                    
                    !!! IMPORTANT !!!
                    _recipients & _feesGenerated should be indexed in the
                    same manner. So...
                    
                    INDEX   |   recipient   |   multiplier  |   percent 
                    0       |   0x1...1     |   00425       |   00.425%
                    1       |   0x1...2     |   51203       |   51.203%
                    ...     |   ...         |   ...         |   ...
                    TOTAL   |   ...         |   100000      |   100%
                    
        Returns:    None
        Notes:      Used to mint tokens for early adopters.
    ***********************************************************************/
    
    function mint(address[] memory _recipients, uint256[] memory _feesGenerated, uint256 _rewardMultiplier) internal onlyOwnerOrAdmin monthPassed returns (uint256 mintedDuringThisPeriod) {
        require(_recipients.length == _feesGenerated.length, "Array lengths don't match... please check inputs.");
        require(_rewardMultiplier <= 100000, "Reward multiplier must be less than or equal to 100000.");
        
        lastBlockMinted = block.number;
        mintedDuringThisPeriod = currentUpperBound().mul(_rewardMultiplier).div(100000);
        
        // Variables to maintain minting functionality
        totalActualMinted = totalActualMinted.add(mintedDuringThisPeriod);
        actualMintedAmount[periodsElapsed] = mintedDuringThisPeriod;
        periodsElapsed = periodsElapsed.add(1);
        totalExtraTokens = totalExtraTokens.add(currentUpperBound().sub(totalActualMinted));
        
        for(uint256 i = 0; i < _recipients.length; i++) {
            // TODO: Figure out how to make the tier multiplier NOT go over mintedDuringThisPeriod
            generatedRewards[_recipients[i]] = generatedRewards[_recipients[i]].
                                                add(
                                                    _feesGenerated[i].
                                                        mul(mintedDuringThisPeriod).
                                                        div(100000)
                                                );
        }
    }
    
    /***********************************************************************
        Function:   beginStakingForAnother()
        Args:       address _participant a participant to add.
        Returns:    None
        Notes:      Used by the owner to add a participant for easy minting 
                        functionality maintenance.
    ***********************************************************************/
    
    function beginStakingForAnother(address _address) public onlyOwnerOrAdmin {
        require(!isStaking[_address], "This user is already staking.");
        isStaking[_address] = true;
        if (stakingPeriod[_address] == 0) stakingPeriod[_address] = block.number;
    }
    
    /***********************************************************************
        Function:   addAdmin()
        Args:       address _admin a new admin.
        Returns:    None
        Notes:      Used by the owner to add an admin for easy minting 
                        functionality maintenance.
    ***********************************************************************/
    
    function addAdmin(address _admin) public onlyOwner {
        mintingAdmins[_admin] = true;
    }
    
    /***********************************************************************
        Function:   revokeAdmin()
        Args:       address _admin of a previous admin.
        Returns:    None
        Notes:      Used by the owner to remove an admin for easy minting 
                        functionality maintenance.
    ***********************************************************************/
    
    function revokeAdmin(address _admin) public onlyOwnerOrAdmin {
        mintingAdmins[_admin] = false;
    }
    
    /***********************************************************************
        Function:   redeemAirdropForAnother()
        Args:       address _other, the user you are redeeming for.
        Returns:    None
        Notes:      Used to redeem the airdrop for another user. Only admins
                        or the owner may use this function.
    ***********************************************************************/
    
    function redeemAirdropForAnother(address _other) public onlyOwnerOrAdmin {
        require(generatedRewards[_other] > 0, "There are no tokens left to redeem.");
        token.transfer(_other, generatedRewards[_other]);
        generatedRewards[_other] = 0;
        stakingPeriod[_other] = block.number;
    }
    
    /******************************   VIEWS   ******************************/ 
    /***********************************************************************
        Function:   getStakingOriginBlock()
        Args:       address _check the address to check the staking origin of.
        Returns:    uint256 startingBlock, the block staking was started.
        Notes:      Used to determine when staking began.
    ***********************************************************************/
    
    function getStakingOriginBlock(address _check) public view returns (uint256 startingBlock) {
        return stakingPeriod[_check];
    }
    
    /***********************************************************************
        Function:   getStakingOriginBlock()
        Args:       None
        Returns:    uint256 startingBlock, the block staking was started.
        Notes:      Used to determine when staking began for the calling user.
    ***********************************************************************/
    
    function getStakingOriginBlock() public view returns (uint256 startingBlock) {
        return stakingPeriod[msg.sender];
    }
    
    /***********************************************************************
        Function:   determineCurrentRewardMultplier()
        Args:       address _check the address to check the staking reward
                        multiplier of.
        Returns:    uint256 stakingMultiplier, the current yield from staking.
        Notes:      Used to determine extra rewards for users who are staking.
    ***********************************************************************/
    
    function determineCurrentStakingMultiplier(address _check) public view returns (uint256 stakingMultiplier) {
        uint256 blocksStaked = block.number.sub(stakingPeriod[_check]);
        uint256 blocksInAYear = blocksInAMonth.mul(12);
        
        stakingMultiplier = ((blocksStaked.mul(1000)).div(blocksInAYear)).add(1000); // max multiplier must be 2x.
        if (stakingMultiplier > 2000) stakingMultiplier = 2000;
        return stakingMultiplier;
    }
    
    /***********************************************************************
        Function:   determineCurrentRewardMultplier()
        Args:       None.
        Returns:    uint256 stakingMultiplier, the current yield from staking.
        Notes:      Used to determine extra rewards for the calling user.
    ***********************************************************************/
    
    function determineCurrentRewardMultplier() public view returns (uint256 stakingMultiplier) {
        uint256 blocksStaked = block.number.sub(stakingPeriod[msg.sender]);
        uint256 blocksInAYear = blocksInAMonth.mul(12);
        
        stakingMultiplier = ((blocksStaked.mul(1000)).div(blocksInAYear)).add(1000); // max multiplier must be 2x.
        if (stakingMultiplier > 2000) stakingMultiplier = 2000;
        return stakingMultiplier;
    }
    
    /***********************************************************************
        Function:   determineCurrentRewardMultplier()
        Args:       uint256 dollar_value the current price DGF is valued at 
                        in THOUSANDS (1001 = $1.001).
                    uint256 totalFeesGenerated the current dollar value in 
                        fees generated since the last minting (no decimal).
        Returns:    uint256 currMultiplier, the current percent to mint.
        Notes:      Used to get the percent of the upper bound to mint. 
                        Percent that is generated is in the HUNDRED THOUSANDS
                        for precision purposes (ie: 24556 = 24.556%).
    ***********************************************************************/
    
    function determineCurrentRewardMultplier(uint256 dollar_value, uint256 totalFeesGenerated) public view returns (uint256 currMultiplier) {
        currMultiplier = (totalFeesGenerated.mul(100000)).div(dollar_value.mul(currentUpperBound().div(10 ** decimals)).div(1000));
        
        if (currMultiplier >= 100000) return 100000;
        return currMultiplier;
    }
    
    /***********************************************************************
        Function:   checkReward()
        Args:       None
        Returns:    None
        Notes:      Used to determine if the calling address has a reward.
    ***********************************************************************/
    
    function checkReward() public view returns (uint256 _reward) {
        return generatedRewards[msg.sender];
    }
    
    /***********************************************************************
        Function:   checkRewardOfAddress()
        Args:       address _check the user you are checking for
        Returns:    None
        Notes:      Used to determine if the calling address has a reward. 
                        Only admins or the owner may use this function.
    ***********************************************************************/
    
    function checkRewardOfAddress(address _check) public view onlyOwnerOrAdmin returns (uint256 _reward) {
        return generatedRewards[_check];
    }
    
    /***********************************************************************
        Function:   currentUpperBound()
        Args:       None
        Returns:    uint256 currBound, the current upper bound.
        Notes:      Used to calculate the current upper bound reward.
    ***********************************************************************/
    
    function currentUpperBound() public view returns (uint256 currBound) {
        return decayMinuend.sub(decaySubtrahend.mul(periodsElapsed));
    }
    
    /***********************************************************************
        Function:   upperBoundOfPeriod()
        Args:       uint256 _period the period to get the upper bound for.
        Returns:    uint256 currBound, the current upper bound.
        Notes:      Used to calculate the current upper bound reward.
    ***********************************************************************/
    
    function upperBoundOfPeriod(uint256 _period) public pure returns (uint256 currBound) {
        return decayMinuend.sub(decaySubtrahend.mul(_period));
    }
    
    
    // TEST FUNCTIONS REMOVE BEFORE DEPLOYING
    
    
    function TEST_determineCurrentStakingMultiplier(uint256 curr_block, uint256 block_staked) public view returns (uint256 stakingMultiplier) {
        uint256 blocksStaked = curr_block.sub(block_staked);
        uint256 blocksInAYear = blocksInAMonth.mul(12);
        
        stakingMultiplier = ((blocksStaked.mul(1000)).div(blocksInAYear)).add(1000); // max multiplier must be 2x.
        if (stakingMultiplier > 2000) stakingMultiplier = 2000;
        return stakingMultiplier;
    }
}