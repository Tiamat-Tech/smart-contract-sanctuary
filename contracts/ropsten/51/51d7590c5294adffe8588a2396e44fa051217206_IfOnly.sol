/*

[email protected]@@[email protected]@@$$$$$$$$$$$$$$$$$$$$$$$$$
[email protected]@W{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$      |[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$      |[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$      |[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
[email protected]     .|[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$      [[email protected]&        @[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$      ]$$$          [email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$      ]$$           @[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$      ]$$       [email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$      ]$$      >[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$      [$$           [email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$      ]$$           [email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$      ]$$      .III;@[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$      ]$$      >[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$      /$$      >[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$      |$$      >[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$      |$$      >[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
[email protected][email protected]&[email protected]$&{{{{{{*$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$%&[email protected]&%[email protected]$&{{{{{{*[email protected]$$$$$$$$$$$
[email protected]@@"           @@@$$       k        [email protected]$&{{{{{{*$       @[email protected]      _$$$$
[email protected]                @[email protected]                  @$&{{{{{{*$$      J$$$$(      @$$$$
[email protected] [email protected]       @$        q$i       @$&{{{{{{*$$Z      $$$$      @$$$$$
[email protected] [email protected]$$$&      [email protected]       @$$$_      @$&{{{{{{*[email protected]     ^@@"     U$$$$$$
$$B      [email protected] [email protected]       $$$$c      @$&{{{{{{*$$$$      @@      @$$$$$$
$$$      '@$$$w      Z$       $$$$c      @$&{{{{{{*$$$$8            $$$$$$$$
$$$t       [email protected];       @$       $$$$c      @$&{{{{{{*$$$$$+          d$$$$$$$$
$$$$o              `@$$       $$$$c      @$&{{{{{{[email protected]          @$$$$$$$$
[email protected]%          [email protected]$$$$       $$$$c      @$&{{{{{{[email protected]        @$$$$$$$$$
[email protected]@@[email protected]@@[email protected]@@@@@@@@B1{{{{W$$$B$m        &$$$$$$$$$$
[email protected]@@{1{{{[email protected]@@@&1a$$$          @$$$$$$$$$$$
[email protected]@){{{{{{{[email protected]@@$$$        M$$$$$$$$$$$$$
[email protected]&{1{{{{{{{{{{1#@@[email protected]@$$$$$$$$$$$$$$$$$$$
[email protected]@@@@j{{{{{{{{{{{{{)[email protected]$$$$$$$$$$$$$$$$$$$
[email protected]@@@@@@@%1{{{{{{{{{{{[email protected]@$$$$$$$$$$$$$$$$
[email protected]@B{}{{1*[email protected]@#){{{{{{{{[email protected]$$$$$$$$$$$$$$$$$
[email protected]@1{{{{{{{{[email protected]@@C{{{{[email protected]$$$$$$$$$$$$$$$$$$
[email protected]@Y1{{{{{{{{{{{[email protected]@@@@$$$$$$$$$$$$$$$$$$$
[email protected][email protected]@W1{1{{{{{{{{{{[email protected]@$$$$$$$$$$$$$$$$$$$
[email protected][email protected]@@@@m{{{{{{{{{{{{[email protected]@@$$$$$$$$$$$$$$$$
[email protected]@{1{{{[email protected]{{{{{{{{{*@$$$$$$$$$$$$$$$$$
[email protected]@{{{{{{{{{)[email protected]@B1{{{{[email protected]$$$$$$$$$$$$$$$$$$
[email protected]@Z{{{{{{{{{{1{1#@@@@@$$$$$$$$$$$$$$$$$$$
[email protected]@@@B){{{{{{{{{{{{{|[email protected]@$$$$$$$$$$$$$$$$$$
[email protected]@{{{{{{{{{{{{{1$$$$$$$$$$$$$$$$$$$
[email protected]{{{{{{{{{{{{{{@$$$$$$$$$$$$$$$$$$
[email protected]@%{{{{{{{{{{{{{[email protected]$$$$$$$$$$$$$$$$$$$
[email protected]){{{{{{{{{{{{{{[email protected]$$$$$$$$$$$$$$$$$$$
[email protected]@%{{{{{{{{[email protected]{{{{{{{[email protected]@@@$$$$$$$$$$$$$$$
[email protected]@@B1{{{{{{{[email protected]@@@U{{{{{{{{[email protected]@$$$$$$$$$$$$$$$
[email protected]{{{{{{{}[email protected][email protected]@@[email protected]{{{{{{[email protected]@@$$$$$$$$$$$$$
[email protected]@@[email protected]{{{{{1{[email protected]@@[email protected]{{{{{{{[email protected]@$$$$$$$$$$$$
[email protected]@@M{{{{{{{1%@@@@[email protected]@@1{{{{{{{|@$$$$$$$$$$$$
[email protected]@({{{{{{{(@@@[email protected]&{{{{{{{{@@@$$$$$$$$$
[email protected]{{{{{{{{%@@@[email protected]@@1{{{{{{{[email protected]@@$$$$$$$
[email protected]@B{{{{{{{[email protected]@[email protected]{{{{{{{[email protected]@@$$$$$$
[email protected]%{{{{{{{[email protected]@B{1{{{{{[email protected]$$$$$$$
[email protected]{{{{{{[email protected][email protected]@@@{1{{{{[email protected]$$$$$$
[email protected]@@1{{{{{{[email protected]@[email protected]{{{{{{{@$$$$$$
[email protected]$#{{{{{1|@@[email protected]{{{{{1|$$$$$$
[email protected]@){{{{{{  https://t.me/ifonlycommunity  1{{{{{{@@$$$$
[email protected]{{{{{{{@[email protected]@@O{{{{{{[email protected]@$$$
[email protected]@{{{{{{[email protected][email protected]@@Q{{{{{{@@@$$$
[email protected]|{{{{{{@[email protected]@/{{{{{{$$$$$$
[email protected]@8{{{{{{[email protected]@B{{{{{{f$$$$$$
[email protected]@@)1{{{{[email protected]@[email protected]@{{{{{{{@$$$$$$
[email protected]@@@1{{{{{[email protected]@[email protected][email protected]{{{{{{[email protected]$$$$$$
[email protected]@1{{{{{1{{[email protected]@@[email protected]@@B1{{{{{{1{%@@$$$$$$
[email protected]@O{{{{{{{{{{{[email protected]@@@@@@@@8J1{{{{{{{{{{[email protected]$$$$$$$$$
[email protected]@@@@v{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{1%@@$$$$$$$$$
[email protected]$B{1{{{{{{{{{{{{{{{{{{{{{1{{{[email protected]@$$$$$$$$$$$$
[email protected]@@@@@*({{{{{{{{{{{{{{{{{{[email protected]@@@@$$$$$$$$$$$$
[email protected]@@@@B&M**#&[email protected]@@@@@$$$$$$$$$$$$$$$$$$$


Are you checking the BTC price from many years ago thinking IF ONLY?
Are you browsing Elon tweets after you missed DOGE and are you thinking IF ONLY?
Are you staring at pumped charts of your free signal group thinking IF ONLY?
Are you missing airdrops worth thousands and thinking IF ONLY?



Quit all your shower thoughts and change your life now! 
Join our beautiful IF ONLY community to participate in our airdrop, meme contest and many more.


IF ONLY is a fair launch community token with excellent tokenomics:

Total token supply : 10,000,000,000 IFONLY

- 5% of the total supply will be airdropped & another 5% will be used to reward contest winners
- 90% of the total supply will be added to the pancakeswap pool
- Initial liquidity will be locked & Auto-LP during transactions is locked automatically


Further features:

1) Whale protection:
Max % to buy in one tx: 1% of total supply
Max % of total supply per wallet 2% of total supply


2) Anti-dump mechanic / LP grows + holders get rewarded:

Sell within 3 hours      : 40% tax (35% Back to the Liquidity Pool, 5% Redistributed to Holders)
Sell within 6 hours      : 35% tax (31% Back to the Liquidity Pool, 4% Redistributed to Holders)
Sell within 12 hours     : 30% tax (27% Back to the Liquidity Pool, 3% Redistributed to Holders)
Sell within 24 hours     : 20% tax (18% Back to the Liquidity Pool, 2% Redistributed to Holders)
Afterwards               : 10% tax ( 9% Back to the Liquidity Pool, 1% Redistributed to Holders)


Chime in and enjoy!
Telegram: https://t.me/ifonlycommunity


*/


// SPDX-License-Identifier: Unlicensed

pragma solidity ^0.6.12;

import './IBEP20.sol';
import './Ownable.sol';
import './SafeMath.sol';
import './IPancakeStuff.sol';


contract IfOnly is Context, IBEP20, Ownable {
    using SafeMath for uint256;

    mapping(address => uint256) private _rOwned;
    mapping(address => uint256) private _tOwned;
    mapping(address => mapping(address => uint256)) private _allowances;

    mapping(address => bool) private _isExcludedFromFee;

    address[] private _excluded;

    uint256 private constant MAX = ~uint256(0);
    bool inSwapAndLiquify;
    uint256 private constant _tTotal = 100 * 10**8 * 10**9; // max supply 10,000,000,000 IFONLY
    uint256 private _rTotal = (MAX - (MAX % _tTotal));
    uint256 private _tFeeTotal;
    uint256 public _taxFee = _getAntiDumpFeeRF(); 
    uint256 public _liquidityFee = _getAntiDumpFeeLP(); 
    uint256 public _previousTaxFee = _taxFee; 
    uint256 public _previousLiquidityFee = _liquidityFee;
    uint256 public _maxTxAmount = 1 * 10**8 * 10**9; // max tokens per tx
    uint256 public _numTokensSellToAddToLiquidity = 5 * 10**7 * 10**9; // amount of tokens to sell into LP
    uint256 public _maxWalletToken = 2 * 10**8 * 10**9; // max tokens per Wallet

    IPancakeRouter02 public immutable pcsV2Router;
    address public immutable pcsV2Pair;

    string private _name = "If Only";
    string private _symbol = "IFONLY";
    uint8 private _decimals = 9;
    uint256 private _start_timestamp = block.timestamp;

    event SwapAndLiquify(
        uint256 tokensSwapped,
        uint256 ethReceived,
        uint256 tokensIntoLiqudity,
        uint256 contractTokenBalance
    );

    constructor() public {
        _rOwned[_msgSender()] = _rTotal;
        _isExcludedFromFee[owner()] = true;
        _isExcludedFromFee[address(this)] = true;

        IPancakeRouter02 _pancakeswapV2Router =
            IPancakeRouter02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
        // Create a pancake pair for this new token
        pcsV2Pair = IPancakeFactory(_pancakeswapV2Router.factory()).createPair(
            address(this),
            _pancakeswapV2Router.WETH()
        );
        pcsV2Router = _pancakeswapV2Router;

        emit Transfer(address(0), _msgSender(), _tTotal);
    }

    modifier lockTheSwap {
        inSwapAndLiquify = true;
        _;
        inSwapAndLiquify = false;
    }

    function name() public view override returns (string memory) {
        return _name;
    }

    function symbol() public view override returns (string memory) {
        return _symbol;
    }

    function decimals() public view override returns (uint8) {
        return _decimals;
    }

    function totalSupply() public view override returns (uint256) {
        return _tTotal;
    }

    function balanceOf(address account) public view override returns (uint256) {
        return tokenFromReflection(_rOwned[account]);
    }

    function transfer(address recipient, uint256 amount)
        public
        override
        returns (bool)
    {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender)
        public
        view
        override
        returns (uint256)
    {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint256 amount)
        public
        override
        returns (bool)
    {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint256 amount
    ) public override returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(
            sender,
            _msgSender(),
            _allowances[sender][_msgSender()].sub(
                amount,
                "ERC20: transfer amount exceeds allowance"
            )
        );
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue)
        public
        virtual
        returns (bool)
    {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender].add(addedValue)
        );
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue)
        public
        virtual
        returns (bool)
    {
        _approve(
            _msgSender(),
            spender,
            _allowances[_msgSender()][spender].sub(
                subtractedValue,
                "ERC20: decreased allowance below zero"
            )
        );
        return true;
    }

    function totalFees() public view returns (uint256) {
        return _tFeeTotal;
    }

    function reflect(uint256 tAmount) public {
        address sender = _msgSender();
        (uint256 rAmount, , , , , ) = _getValues(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _rTotal = _rTotal.sub(rAmount);
        _tFeeTotal = _tFeeTotal.add(tAmount);
    }

    function reflectionFromToken(uint256 tAmount, bool deductTransferFee)
        public
        view
        returns (uint256)
    {
        require(tAmount <= _tTotal, "Amount must be less than supply");
        if (!deductTransferFee) {
            (uint256 rAmount, , , , , ) = _getValues(tAmount);
            return rAmount;
        } else {
            (, uint256 rTransferAmount, , , , ) = _getValues(tAmount);
            return rTransferAmount;
        }
    }

    function tokenFromReflection(uint256 rAmount)
        public
        view
        returns (uint256)
    {
        require(
            rAmount <= _rTotal,
            "Amount must be less than total reflections"
        );
        uint256 currentRate = _getRate();
        return rAmount.div(currentRate);
    }

    function _approve(
        address owner,
        address spender,
        uint256 amount
    ) private {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }

// useless since variable not in use anymore
    function removeAllFee() private {
        if (_taxFee == 0 && _liquidityFee == 0) return;

        _previousTaxFee = _getAntiDumpFeeRF();
        _previousLiquidityFee = _getAntiDumpFeeLP();

        _taxFee = 0;
        _liquidityFee = 0;
    }

// useless since variable not in use anymore
    function restoreAllFee() private {
        _taxFee = _getAntiDumpFeeRF();
        _liquidityFee = _getAntiDumpFeeLP();
    }

    function _transfer(
        address sender,
        address recipient,
        uint256 amount
    ) private {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");
        require(amount > 0, "Transfer amount must be greater than zero");
        if (
            sender != owner() &&
            recipient != owner() &&
            recipient != address(1) &&
            recipient != pcsV2Pair
        ) {
            require(
                amount <= _maxTxAmount,
                "Transfer amount exceeds the maxTxAmount (100,000,000)"
            );
            uint256 contractBalanceRecepient = balanceOf(recipient);
            require(
                contractBalanceRecepient + amount <= _maxWalletToken,
                "Exceeds maximum wallet token amount (200,000,000)"
            );
        }

        // is the token balance of this contract address over the min number of
        // tokens that we need to initiate a swap + liquidity lock?
        // also, don't get caught in a circular liquidity event.
        // also, don't swap & liquify if sender is uniswap pair.
        uint256 contractTokenBalance = balanceOf(address(this));

        if (contractTokenBalance >= _maxTxAmount) {
            contractTokenBalance = _maxTxAmount;
        }

        bool overMinTokenBalance =
            contractTokenBalance >= _numTokensSellToAddToLiquidity;
        if (overMinTokenBalance && !inSwapAndLiquify && sender != pcsV2Pair) {
            contractTokenBalance = _numTokensSellToAddToLiquidity;
            swapAndLiquify(contractTokenBalance);
        }

        bool takeFee = true;

        //if any account belongs to _isExcludedFromFee account then remove the fee
        if (
            _isExcludedFromFee[sender] ||
            _isExcludedFromFee[recipient] ||
            sender == pcsV2Pair
        ) {
            takeFee = false;
        }

        if (!takeFee) removeAllFee();

        _transferStandard(sender, recipient, amount);

        if (!takeFee) restoreAllFee();
    }

    function _transferStandard(
        address sender,
        address recipient,
        uint256 tAmount
    ) private {
        (
            uint256 rAmount,
            uint256 rTransferAmount,
            uint256 rFee,
            uint256 tTransferAmount,
            uint256 tFee,
            uint256 tLiquidity
        ) = _getValues(tAmount);
        _rOwned[sender] = _rOwned[sender].sub(rAmount);
        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);
        _takeLiquidity(tLiquidity);
        _reflectFee(rFee, tFee);
        emit Transfer(sender, recipient, tTransferAmount);
    }

    function _reflectFee(uint256 rFee, uint256 tFee) private {
        _rTotal = _rTotal.sub(rFee);
        _tFeeTotal = _tFeeTotal.add(tFee);
    }

    function _getValues(uint256 tAmount)
        private
        view
        returns (
            uint256,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256
        )
    {
        (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) =
            _getTValues(tAmount);
        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) =
            _getRValues(tAmount, tFee, tLiquidity, _getRate());
        return (
            rAmount,
            rTransferAmount,
            rFee,
            tTransferAmount,
            tFee,
            tLiquidity
        );
    }

// function to determine reflect fee
    function _getAntiDumpFeeRF() private view returns (uint256) {
        uint256 time_since_start = block.timestamp - _start_timestamp;
        uint256 hour = 60 * 60; // 3600 seconds
        // uint256 minute = 60; -> not needed
        if (time_since_start < 3 * hour) {
            return (5);
        } else if (time_since_start < 6 * hour) {
            return (4);
        } else if (time_since_start < 12 * hour) {
            return (3);
        } else if (time_since_start < 24 * hour) {
            return (2);
        } else {
            return (1);
        }
    }

// function to determine LP fee
     function _getAntiDumpFeeLP() private view returns (uint256) {
        uint256 time_since_start = block.timestamp - _start_timestamp;
        uint256 hour = 60 * 60; // 3600 seconds
        // uint256 minute = 60; -> not needed
        if (time_since_start < 3 * hour) {
            return (35);
        } else if (time_since_start < 6 * hour) {
            return (31);
        } else if (time_since_start < 12 * hour) {
            return (27);
        } else if (time_since_start < 24 * hour) {
            return (18);
        } else {
            return (9);
        }
    }

    function _getTValues(uint256 tAmount)
        private
        view
        returns (
            uint256,
            uint256,
            uint256
        )
    {
        uint256 feeRF = _getAntiDumpFeeRF(); // set multiplier in comparision to standard fees (reflect)
        uint256 feeLP = _getAntiDumpFeeLP(); // set multiplier in comparision to standard fees (LP)
        uint256 tFee = tAmount.div(10**2).mul(feeRF); // set reflect with current fee
        uint256 tLiquidity =
            tAmount.div(10**2).mul(feeLP); // set LP add with current fee
        uint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity); // final TX amount for wallet
        return (tTransferAmount, tFee, tLiquidity);
    }

    function _getRValues(
        uint256 tAmount,
        uint256 tFee,
        uint256 tLiquidity,
        uint256 currentRate
    )
        private
        pure
        returns (
            uint256,
            uint256,
            uint256
        )
    {
        uint256 rAmount = tAmount.mul(currentRate);
        uint256 rFee = tFee.mul(currentRate);
        uint256 rLiquidity = tLiquidity.mul(currentRate);
        uint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity);
        return (rAmount, rTransferAmount, rFee);
    }

    function _getRate() private view returns (uint256) {
        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();
        return rSupply.div(tSupply);
    }

    function _getCurrentSupply() private view returns (uint256, uint256) {
        uint256 rSupply = _rTotal;
        uint256 tSupply = _tTotal;
        for (uint256 i = 0; i < _excluded.length; i++) {
            if (
                _rOwned[_excluded[i]] > rSupply ||
                _tOwned[_excluded[i]] > tSupply
            ) return (_rTotal, _tTotal);
            rSupply = rSupply.sub(_rOwned[_excluded[i]]);
            tSupply = tSupply.sub(_tOwned[_excluded[i]]);
        }
        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);
        return (rSupply, tSupply);
    }

    function _takeLiquidity(uint256 tLiquidity) private {
        uint256 currentRate = _getRate();
        uint256 rLiquidity = tLiquidity.mul(currentRate);
        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);
    }

    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {
        // split the contract balance into halves
        uint256 half = contractTokenBalance.div(2);
        uint256 otherHalf = contractTokenBalance.sub(half);

        // capture the contract's current BNB balance.
        // this is so that we can capture exactly the amount of ETH that the
        // swap creates, and not make the liquidity event include any ETH that
        // has been manually sent to the contract
        uint256 initialBalance = address(this).balance;

        // swap tokens for BNB
        swapTokensForBNB(half);

        // how much BNB did we just swap into?
        uint256 newBalance = address(this).balance.sub(initialBalance);

        // add liquidity to uniswap
        addLiquidity(otherHalf, newBalance);

        emit SwapAndLiquify(half, newBalance, otherHalf, contractTokenBalance);
    }

    function swapTokensForBNB(uint256 tokenAmount) private {
        // generate the uniswap pair path of token -> weth
        address[] memory path = new address[](2);
        path[0] = address(this);
        path[1] = pcsV2Router.WETH();

        _approve(address(this), address(pcsV2Router), tokenAmount);

        // make the swap
        pcsV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(
            tokenAmount,
            0, // accept any amount of ETH
            path,
            address(this),
            block.timestamp
        );
    }

    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {
        // approve token transfer to cover all possible scenarios
        _approve(address(this), address(pcsV2Router), tokenAmount);

        // add the liquidity
        pcsV2Router.addLiquidityETH{value: ethAmount}(
            address(this),
            tokenAmount,
            0, // slippage is unavoidable
            0, // slippage is unavoidable
            owner(),
            block.timestamp
        );
    }

    receive() external payable {}
}