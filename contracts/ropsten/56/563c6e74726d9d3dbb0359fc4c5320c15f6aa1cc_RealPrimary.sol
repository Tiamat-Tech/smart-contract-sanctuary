/**
 *Submitted for verification at Etherscan.io on 2021-08-25
*/

// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.7.0 <0.8.0;

contract RealPrimary {
    
    NewReal[] public newReals; // the array that includes all the reals 
    
    uint indexInArray = 0; // the index of the newReals array.
    
    mapping(address =>uint) public realListFromAddressToArrayId; // this is for mapping the offer hash address, which has been created by this smart contract, to the newReals array. 
    mapping( uint =>address) public realListFromIdToaddress; // this is for for mapping the id, which has been generated by the local system, with the hash address that is generated by the smart contract.
    
    event Event(
       address owner,
       bytes16 photo,
       uint indexed id,
       uint indexed certificate,
       address indexed contractAddress,
       uint256 value,
       bool valid,
       bool availability
    ); // the events will be globally presented in the smart contract account in the etherscan.
    
   function setReal(address payable _owner_1, uint256  _value_1, uint _id, bytes16 _md5_hash_picture, uint _certificate) public { // register a new real estate.
       
        for (uint i = 0; i < newReals.length; i++) {// the propetry could be added twice or more, so this algorithm will check several aspects as below.
            
            if((newReals[i].getMd5HashPicture() == _md5_hash_picture || newReals[i].getTheCertificate() == _certificate
            || newReals[i].getId() == _id) && newReals[i].getValid() == true){ // if the certificate or the hash value of the main picture or the id of the property has been added by the blockchain database, and this property is valid, then the algorithm will check additional aspects as below. 
            
            if (newReals[i].getAvailable() == true){ // if the property satisfies the above conditions, then the algorithm will check if the property has been sold or not. 
                                require(newReals[i].getOwner() == _owner_1 && newReals[i].getValue() != _value_1,'This is offer has been added'); // if the property has not been sold before, and the actual owner wants to change the price, then the smart contract set the previous offer as unvalid offer. After this algorithm, a new offer will be created by the parameters that have been sent.
                                newReals[i].cancelOffer();// set the previous offer as unvalid offer, a prepering for creating a new one.
            
            }else{
                require(newReals[i].getOwner() == _owner_1,'The owner who try to add this offer is not the actual owner!'); // if the property has been registered and sold, and the old owner or anyone wants to upload the property, then the smart contract prevents the setReal function. 
            }
        }
        }
          
   
        newReals.push( new NewReal(_owner_1, _value_1, _id, _certificate , _md5_hash_picture)); // push a new real estate in the arreay.

      
      realListFromIdToaddress[_id] = newReals[indexInArray].getThisContractAddress();
      realListFromAddressToArrayId[realListFromIdToaddress[_id]] = indexInArray;
      
      indexInArray = indexInArray +1; //when a new real estate is added, indexInArray will be increased by 1.
      
       emit Event(
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getOwner(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getMd5HashPicture(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getId(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getValue(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getThisContractAddress(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getTheCertificate(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getValid(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getAvailable()
   ); // update the events.
   
   }
   
    function buy(address offerHashAddress) payable public  { 
      
      require(newReals[realListFromAddressToArrayId[offerHashAddress]].getValue() == msg.value, 'The price is not equal the actual price'); // first condition, the price must be equal the real estate price.
      
      require(newReals[realListFromAddressToArrayId[offerHashAddress]].getAvailable() == true, 'The property is sold, or it is not available'); // second condition, the real estate must be available.
      
     require(newReals[realListFromAddressToArrayId[offerHashAddress]].getValid() == true, 'This offer is not valid, please visit the real estate authority'); // third condition, the real estate must be valid. 

      newReals[realListFromAddressToArrayId[offerHashAddress]].getOwner().transfer(msg.value); // transfer the amount to the previous owner.
        
      newReals[realListFromAddressToArrayId[offerHashAddress]].setUnavailable(msg.sender); // update the address to the new owner's address.
      
       emit Event(
        newReals[realListFromAddressToArrayId[offerHashAddress]].getOwner(),
        newReals[realListFromAddressToArrayId[offerHashAddress]].getMd5HashPicture(),
        newReals[realListFromAddressToArrayId[offerHashAddress]].getId(),
        newReals[realListFromAddressToArrayId[offerHashAddress]].getValue(),
        newReals[realListFromAddressToArrayId[offerHashAddress]].getThisContractAddress(),
        newReals[realListFromAddressToArrayId[offerHashAddress]].getTheCertificate(),
        newReals[realListFromAddressToArrayId[offerHashAddress]].getValid(),
       newReals[realListFromAddressToArrayId[offerHashAddress]].getAvailable()
   ); // update the events.
      
    }
    
    
    function getValidForAnyContract(address offerHashAddress) public view returns (bool) { // return the validity of the offer according to the id, which has been generated by the local system.
    
    return newReals[realListFromAddressToArrayId[offerHashAddress]].getValid() ;
    
    }
    
    
    function getAnyContractAddress(uint _id) public view returns (address) { // return the hash address of the offer according to the id, which has been generated by the local system.
    
   
        return  realListFromIdToaddress[_id];
    
   }
   
   function getAvailablilityForAnyContract(uint _id) public view returns (bool) { // return the current availability of the offer according to the id, which has been generated by the local system.
    
    return newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getAvailable();

   }
   
   function getValueForAnyContract(uint _id) public view returns (uint256) { // return the price of the offer according to the id, which has been generated by the local system.
    
    return newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getValue();

   }
   
   function getOwnerForAnyContract(uint _id) public view returns (address) { // return the current owner of the offer according to the id, which has been generated by the local system.
    
    return newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getOwner();

   }
   
   function cancelOffer(address offerHashAddress) public { // cancel this offer.
    require(newReals[realListFromAddressToArrayId[offerHashAddress]].getValid() == true, 'The offer has already been canceled');
    require(newReals[realListFromAddressToArrayId[offerHashAddress]].getAvailable() == true,' The offer can not be canceled owing to the offer has already been sold!');
    newReals[realListFromAddressToArrayId[offerHashAddress]].cancelOffer();
    
   }
   
  
}

contract NewReal{ // this the sub contract that will generated by the main contract RealPrimary
    
   address payable owner;
   uint256  value;
   uint id;
   uint certificate;
   bytes16 md5_hash_picture; // this is the hash value of this property's photo ,which has been uploaded by the local system.
   bool available;
   bool valid = false;
   
   constructor(address payable _owner, uint256 _value, uint _id, uint _certificate ,bytes16   _md5_hash_picture){
    id = _id;
    certificate = _certificate;
    owner = _owner;
    value = _value;
    md5_hash_picture = _md5_hash_picture;
    available = true; // if this variable is true, then the property is for sell now.
    valid = true;
   
   }
   
   function getOwner()   public view  returns (address payable) { // return the owner of this offer.
    
    return owner;
   
   }
    function getValue()  public view returns (uint256) { // return the value of this offer.
    
    return value;
   }
   
   function getId()  public view returns (uint) { // return the id of this offer.
    
    return id;
   }
   
    function getTheCertificate()  public view returns (uint) { // return the id of this offer.
    
    return certificate;
   }
   
   function getMd5HashPicture()  public view returns (bytes16) { // return the hash value of the property' photo of this offer.
    
    return md5_hash_picture;
   }
   
    function getAvailable() public view returns (bool) { // return the current availability of this offer.
    
    return available;
   }
   
   function getThisContractAddress() public view returns (address) { // return the hash address of this offer.
    
    return address(this);
   }
   
   
   function setUnavailable(address payable newOwner) public { // update the owner address from the previous owner address to the msg.sender address.
    
    owner = newOwner;
    available = false;
    
   }

   function getValid() public view returns (bool) { // return the validation of this offer.
    
    return valid;
   }
   
   function cancelOffer() public { // cancel this offer.
   // the offer can be canceled only if the property is still for sale. 
    valid = false;
    
   }
   
}