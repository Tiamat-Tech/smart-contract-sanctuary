/**
 *Submitted for verification at Etherscan.io on 2021-11-15
*/

/*
Generated by Jthereum BETA version!
┌──────────────┬──────────────────────────────┐
│     Atribute │                        Value │
├──────────────┼──────────────────────────────┤
│      Version │           2.1.3.391.release1 │
│         Beta │                         true │
│ Build Number │                          391 │
│   Build Date │ Sun Feb 28 00:02:38 EST 2021 │
│   Short Hash │                 463ed1eb55e0 │
│ Installation │ 0x3a3f2302e4eff8f368253fe8f7 │
└──────────────┴──────────────────────────────┘

*/
// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.7.6;

contract BasicToken
{
	string public _name = string("Motu Coin");
	string public _symbol = string("MOTU");
	uint8 public _decimals = uint8(uint8(8));
	uint256 private initialSupply = uint256(uint256(100_000_000_000_000_000));
	mapping (address => uint256) private balancesByAddress;
	constructor() public 
	{
		balancesByAddress[msg.sender] = initialSupply;
	}
	function name() public view returns (string memory) 
	{
		return _name;
	}
	function symbol() public view returns (string memory) 
	{
		return _symbol;
	}
	function decimals() public returns (uint8) 
	{
		return _decimals;
	}
	function totalSupply() public view returns (uint256) 
	{
		return initialSupply;
	}
	function transfer(address _recipient, uint256 _amount) public returns (bool) 
	{
		require((balancesByAddress[msg.sender] >= uint256(_amount)), "Not enough funds");
		require(!(_recipient == msg.sender), "No need to send tokens to yourself");
		uint256 newSenderBalance = uint256((balancesByAddress[msg.sender] - uint256(_amount)));
		uint256 newRecipientBalance = uint256((balancesByAddress[_recipient] + uint256(_amount)));
		require((newRecipientBalance >= uint256(balancesByAddress[_recipient])));
		balancesByAddress[msg.sender] = newSenderBalance;
		balancesByAddress[_recipient] = newRecipientBalance;
		emit Transfer(msg.sender, _recipient, _amount);
		return true;
	}
	function allowance(address owner, address spender) public returns (uint256) 
	{
		return 0;
	}
	function transferFrom(address from, address to, uint256 value) public returns (bool) 
	{
		return false;
	}
	function approve(address spender, uint256 value) public returns (bool) 
	{
		return false;
	}
	function balanceOf(address who) public view returns (uint256) 
	{
		return balancesByAddress[who];
	}

	
	// Imported Event declarations
	event Transfer(address indexed from, address indexed to, uint256 value);

	event Approval(address indexed owner, address indexed spender, uint256 value);


}

/*
 * Below is the original Java source used as input to Jthereum.
 * To regenerate the exact Java source files, remove all below single line
 * comments that start at column zero, and place the source in the indicated file.
 */

/*
 * Source for class com.teammotu.motucoin.BasicToken
 * File Path: ./src/com/teammotu/motucoin/BasicToken.java
 */

// package com.teammotu.motucoin;
// 
// import com.u7.copyright.*;
// import com.u7.jthereum.annotations.*;
// import com.u7.jthereum.types.*;
// import com.u7.jthereum.wellKnownInterfaces.*;
// 
// import static com.u7.util.gg.cf;
// import static com.u7.jthereum.Jthereum.*;
// import static com.u7.jthereum.ContractStaticImports.*;
// 
// //@DefaultContractLocation(address = "0x0f0d0dbb31651aea025084a3be17efdf3c110031", blockchainName = "test", deployedInBlockNumber = 11429844)
// public class BasicToken implements ERC20
// {
// 	public final String _name = "Motu Coin";
// 	public final String _symbol = "MOTU";
// 
// 	public final Uint8 _decimals = Uint8.valueOf(8);
// 
// 	private final Uint256 initialSupply = Uint256.valueOf(100_000_000_000_000_000L);
// 
// 	// All of the balances
// 	final Mapping<Address, Uint256> balancesByAddress = new Mapping<>();
// 
// 	public BasicToken()
// 	{
// 		// set up initial supply
// 		balancesByAddress.put(msg.sender, initialSupply);
// 	}
// 
// 	@Override
// 	@View
// 	public String name()
// 	{
// 		return _name;
// 	}
// 
// 	@Override
// 	@View
// 	public String symbol()
// 	{
// 		return _symbol;
// 	}
// 
// 	@Override
// 	public Uint8 decimals()
// 	{
// 		return _decimals;
// 	}
// 
// 	@Override
// 	@View
// 	public Uint256 totalSupply()
// 	{
// 		return initialSupply;
// 	}
// 
// 	@Override
// 	public boolean transfer(final Address _recipient, final Uint256 _amount)
// 	{
// 		require(balancesByAddress.get(msg.sender).greaterThanOrEqual(_amount), "Not enough funds");
// 		require(!_recipient.equals(msg.sender), "No need to send tokens to yourself");
// 
// 		// Compute the new balances
// 		final Uint256 newSenderBalance = balancesByAddress.get(msg.sender).subtract(_amount);
// 		final Uint256 newRecipientBalance = balancesByAddress.get(_recipient).add(_amount);
// 
// 		require(newRecipientBalance.greaterThanOrEqual(balancesByAddress.get(_recipient))); //overflow check
// 
// 		balancesByAddress.put(msg.sender, newSenderBalance);
// 		balancesByAddress.put(_recipient, newRecipientBalance);
// 
// 		// Log the transaction
// 		emitEvent(new Transfer(msg.sender, _recipient, _amount));
// 
// 		return true;
// 	}
// 
// 	@Override
// 	public Uint256 allowance(final Address owner, final Address spender)
// 	{
// 		return null;
// 	}
// 
// 	@Override
// 	public boolean transferFrom(final Address from, final Address to, final Uint256 value)
// 	{
// 		return false;
// 	}
// 
// 	@Override
// 	public boolean approve(final Address spender, final Uint256 value)
// 	{
// 		return false;
// 	}
// 
// 	@Override
// 	@View
// 	public Uint256 balanceOf(final Address who)
// 	{
// 		return balancesByAddress.get(who);
// 	}
// 
// 
// 	public static void main(final String[] args)
// 	{
// 		compileAndDeploy();
// 
// 		final BasicToken t = (BasicToken)createProxy();
// 
// 		// burn some tokens
// 		t.transfer(Address.ZERO, new Uint256(1000));
// 
// 		String myAddress = getMyAddress();
// 		p("My Balance: " + cf(t.balanceOf(new Address(myAddress))));
// 	}
// }

/*
 * Source for class com.u7.jthereum.wellKnownInterfaces.ERC20
 * File Path: /Users/uditgupta/Library/Jthereum/ProvidedSource/com/u7/jthereum/wellKnownInterfaces/ERC20.java
 */

// package com.u7.jthereum.wellKnownInterfaces;
// 
// import com.u7.copyright.*;
// import com.u7.jthereum.*;
// import com.u7.jthereum.annotations.*;
// import com.u7.jthereum.types.*;
// 
// public interface ERC20
// {
// 	@View
// 	public Uint256 balanceOf(Address who);
// 
// 	public boolean transfer(Address to, Uint256 value);
// 
// 	@View
// 	public Uint256 allowance(Address owner, Address spender);
// 
// 	public boolean transferFrom(Address from, Address to, Uint256 value);
// 
// 	public boolean approve(Address spender, Uint256 value);
// 
// 	@View
// 	public String name();
// 
// 	@View
// 	public String symbol();
// 
// 	@View
// 	public Uint8 decimals();
// 
// 	@View
// 	public Uint256 totalSupply();
// 
// 	@EventClass
// 	public static class Transfer
// 	{
// 		@Indexed
// 		Address from;
// 		@Indexed
// 		Address to;
// 		Uint256 value;
// 
// 		public Transfer(final Address from, final Address to, final Uint256 value)
// 		{
// 			this.from = from;
// 			this.to = to;
// 			this.value = value;
// 		}
// 	}
// 
// 	@EventClass
// 	public static class Approval
// 	{
// 		@Indexed
// 		Address owner;
// 		@Indexed
// 		Address spender;
// 		Uint256 value;
// 
// 		public Approval(final Address owner, final Address spender, final Uint256 value)
// 		{
// 			this.owner = owner;
// 			this.spender = spender;
// 			this.value = value;
// 		}
// 	}
// }