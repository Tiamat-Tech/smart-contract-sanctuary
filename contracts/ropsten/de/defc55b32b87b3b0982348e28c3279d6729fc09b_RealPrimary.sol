/**
 *Submitted for verification at Etherscan.io on 2021-08-26
*/

// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.7.0 <0.8.0;

contract RealPrimary {
    
    address public theContractOwner = payable(0x47E97ac87340CCF9B5d041ebF5394ef37BC52dA9);
    
    NewReal[] public newReals; // the array that includes all the reals 
    
    uint indexInArray = 0; // the index of the newReals array.
    
    mapping(address =>uint) public realListFromAddressToArrayId; // this is for mapping the offer hash address, which has been created by this smart contract, to the newReals array. 
    mapping( uint =>address) public realListFromIdToaddress; // this is for for mapping the id, which has been generated by the local system, with the hash address that is generated by the smart contract.
    mapping( uint =>address) public realListFromIdToTheWoner; 
    mapping( uint =>bool) public realListFromIdToTheAvailability;
    mapping( uint =>bool) public realListFromIdToTheValidation;
    mapping( uint =>uint) public realListFromIdToTheCertificate;
    mapping( uint =>uint256) public realListFromIdToTheValue;
    mapping( uint =>bytes16) public realListFromIdToTheMd5_hash_picture;
    
    
    event Event(
       address owner,
       bytes16 photo,
       uint indexed id,
       uint256 value,
       address contractAddress,
       uint certificate,
       bool valid,
       bool availability
    ); // the events will be globally presented in the smart contract account in the etherscan.
    
   function setReal(address payable _owner_1, uint256  _value_1, uint _id, bytes16 _md5_hash_picture, uint _certificate) public { // register a new real estate.
       
        for (uint i = 0; i < newReals.length; i++) {// the propetry could be added twice or more, so this algorithm will check several aspects as below.
            
            if((newReals[i].getTheCertificate() == _certificate || newReals[i].getId() == _id) && (newReals[i].getValid() == true)){ // if the certificate, the id or the hash value of the picture of the property has been added by the blockchain database, and this property is valid, then the algorithm will check additional aspect as below. 
            
                    newReals[i].cancelOffer();// set the previous offer as unvalid offer, a prepering for creating a new one.
            
            }
        }
        
          
        newReals.push( new NewReal(_owner_1, _value_1, _id, _certificate , _md5_hash_picture)); // push a new real estate in the arreay.

      
      realListFromIdToaddress[_id] = newReals[indexInArray].getThisContractAddress();
      realListFromIdToTheWoner[_id] = newReals[indexInArray].getOwner();
      realListFromIdToTheAvailability[_id] = newReals[indexInArray].getAvailable(); 
      realListFromIdToTheValidation[_id] = newReals[indexInArray].getValid();
      realListFromIdToTheCertificate[_id] = newReals[indexInArray].getTheCertificate();
      realListFromIdToTheValue[_id] = newReals[indexInArray].getValue();
      realListFromIdToTheMd5_hash_picture[_id] = newReals[indexInArray].getMd5HashPicture();
      realListFromAddressToArrayId[realListFromIdToaddress[_id]] = indexInArray; 
      
      indexInArray = indexInArray +1; //when a new real estate is added, indexInArray will be increased by 1.
      
       emit Event(
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getOwner(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getMd5HashPicture(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getId(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getValue(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getThisContractAddress(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getTheCertificate(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getValid(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getAvailable()
   ); // update the events.
   
   }
   
    function buy(uint _id) payable public  { 
      
        require(newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getValid() == true, 'This offer is not valid, please visit the real estate authority'); // third condition, the real estate must be valid. 

        require(newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getAvailable() == true, 'The property has already been sold, or it is not available'); // second condition, the real estate must be available.

        require(newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getValue() == msg.value, 'The price is not equal the actual price'); // first condition, the price must be equal the real estate price.
      
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getOwner().transfer(msg.value); // transfer the amount to the previous owner.
        
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].setAsSold(msg.sender); // update the address to the new owner's address.
        
        realListFromIdToTheAvailability[_id] = newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getAvailable(); //update the main smart contract
        
        realListFromIdToTheWoner[_id] = newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getOwner(); //update the main smart contract
    
        realListFromIdToTheValidation[_id] = newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getValid(); //update the main smart contract
       
       emit Event(
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getOwner(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getMd5HashPicture(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getId(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getValue(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getThisContractAddress(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getTheCertificate(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getValid(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getAvailable()
   ); // update the events.
      
    }
    
    
    function getValidForAnyContract(uint _id) public view returns (bool) { // return the validity of the offer according to the id, which has been generated by the local system.
    
    return realListFromIdToTheValidation[_id];
    
    }
    
    function getValidForAnyContractByaddress(address offerHash) public view returns (bool) { // return the validity of the offer according to the id, which has been generated by the local system.
    
    return  newReals[realListFromAddressToArrayId[offerHash]].getValid();
    
    }
    
    
    function getAnyContractAddress(uint _id) public view returns (address) { // return the hash address of the offer according to the id, which has been generated by the local system.
    
   
    return  realListFromIdToaddress[_id];
    
   }
   
   function getAvailablilityForAnyContract(uint _id) public view returns (bool) { // return the current availability of the offer according to the id, which has been generated by the local system.
    
    return realListFromIdToTheAvailability[_id];

   }
   
   function getValueForAnyContract(uint _id) public view returns (uint256) { // return the price of the offer according to the id, which has been generated by the local system.
    
    return realListFromIdToTheValue[_id];

   }
   
   function getOwnerForAnyContract(uint _id) public view returns (address) { // return the current owner of the offer according to the id, which has been generated by the local system.
    
    return realListFromIdToTheWoner[_id];

   }
   
   function getAnyCertificate(uint _id) public view returns (uint) { // return the current owner of the offer according to the id, which has been generated by the local system.
    
    return realListFromIdToTheCertificate[_id];

   }
   
   function getTheHashValueForAnyContract(uint _id) public view returns (bytes16) { // return the current owner of the offer according to the id, which has been generated by the local system.
    
    return realListFromIdToTheMd5_hash_picture[_id];

   }
   
   function cancelOffer(uint _id) public { // cancel this offer.
    
    require(realListFromIdToTheValidation[_id] == true, 'The offer has already been canceled or sold!');
    require(newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getOwner() == msg.sender
    || msg.sender == theContractOwner, 'You are not authorised to cancel the offer');
    
    newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].cancelOffer(); // set unvaalid.
    realListFromIdToTheValidation[_id] = newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getValid(); // for update the main contract.
    
    emit Event(
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getOwner(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getMd5HashPicture(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getId(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getValue(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getThisContractAddress(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getTheCertificate(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getValid(),
        newReals[realListFromAddressToArrayId[realListFromIdToaddress[_id]]].getAvailable()
   ); // update the events.
    
   }
   
}

contract NewReal{ // this the sub contract that will generated by the main contract RealPrimary
    
   address payable owner;
   uint256  value;
   uint id;
   uint certificate;
   bytes16 md5_hash_picture; // this is the hash value of this property's photo ,which has been uploaded by the local system.
   bool available = false;
   bool valid = false;
   
   constructor(address payable _owner, uint256 _value, uint _id, uint _certificate ,bytes16   _md5_hash_picture){
    id = _id;
    certificate = _certificate;
    owner = _owner;
    value = _value;
    md5_hash_picture = _md5_hash_picture;
    available = true; // if this variable is true, then the property is for sell now.
    valid = true;
   
   }
   
   function getOwner()   public view  returns (address payable) { // return the owner of this offer.
    
    return owner;
   
   }
    function getValue()  public view returns (uint256) { // return the value of this offer.
    
    return value;
   }
   
   function getId()  public view returns (uint) { // return the id of this offer.
    
    return id;
   }
   
    function getTheCertificate()  public view returns (uint) { // return the id of this offer.
    
    return certificate;
   }
   
   function getMd5HashPicture()  public view returns (bytes16) { // return the hash value of the property' photo of this offer.
    
    return md5_hash_picture;
   }
   
    function getAvailable() public view returns (bool) { // return the current availability of this offer.
    
    return available;
   }
   
   function getThisContractAddress() public view returns (address) { // return the hash address of this offer.
    
    return address(this);
   }
   
   function setAsSold(address payable newOwner) public { // update the owner address from the previous owner address to the msg.sender address.
    
    owner = newOwner;
    available = false;
    valid = false;
    
   }

   function getValid() public view returns (bool) { // return the validation of this offer.
    
    return valid;
   }
   
   function cancelOffer() public { // cancel this offer.
   // the offer can be canceled only if the property is still for sale. 
    valid = false;
    
   }
   
}