/**
 * Non-Fungible Generatives(NFG)
 * NFG (Non-Fungible Generatives) is an entity at least contains one NFT and the non-fungible data
 * generated by an algorithm which often refer to generative artificial intelligence.
 *
 *The Genesis Islands of MOSSAI metaverse are the first NFG implementation.
 *
 *MOSSAI, You have been metastruck.
 */

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

/**
 * Each Island NFG is generated with randon wieght of smart dust (infomation substance)
 * 63% has 0.005 gram, 15%-0.006, 10%-0.009, 4%-0.011
 * only 1024 seeds could be used to generate islands NFG
 * the seed ranges from 0 to 2^32 -1
 * the seed could be reused to mint a new NFG and the owner of this seed just pay gas
 * otherwise need to pay 0.05 eth
 */
contract MOSSAI is ERC721URIStorage {
    uint256[] dust_scale = [63, 15, 10, 8, 4];

    string[] private dusts = ["0.005", "0.006", "0.008", "0.009", "0.011"];

    event eveMint(uint256 tokenId, string dusts);
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    mapping(uint256 => string) private _dusts;

    mapping(uint32 => uint256) private _seeds;

    mapping(uint256 => uint32) private _tokens;

    mapping(uint32 => uint256[]) private _mintRecords;

    address platformWallet = 0xc7F61918a81f8590432c950220FEA7Ba922cbe87;

    uint256 mintPrice = 50000000000000000;

    uint256 private _serviceCharge = 5;

    uint256 public _seedTotalNum = 0;

    constructor() ERC721("MOSSAI Islands", "MOSS") {}

    function mint(
        address ownerAddress,
        string memory tokenURI,
        uint32 seedID
    ) public payable returns (uint256) {
        require(seedID > 0, "invalid seed");

        address minter = msg.sender;

        uint256 tokenId = _seeds[seedID];

        if (tokenId == 0) {
            if (minter != platformWallet) {
                require(msg.value == mintPrice, "invalid mint price");
                uint256 serviceAmount = (mintPrice * _serviceCharge) / 100;
                address payable platform = _make_payable(platformWallet);

                platform.transfer(serviceAmount);
                platform.transfer(mintPrice - serviceAmount);
            }
            _seedTotalNum++;
            require(
                _seedTotalNum <= 1024,
                "Reached the upper limit of the coin"
            );
        } else {
            address owner = ownerOf(tokenId);
            require(
                minter == owner && ownerAddress == owner,
                "The owner can operate"
            );
            _tokens[tokenId] = 0;
        }

        _tokenIds.increment();
        uint256 newItemId = _tokenIds.current();
        _mint(ownerAddress, newItemId);
        _setTokenURI(newItemId, tokenURI);

        string memory dust = pluck(newItemId, dusts, dust_scale);
        _dusts[newItemId] = dust;

        _tokens[newItemId] = seedID;
        _seeds[seedID] = newItemId;

        _mintRecords[seedID].push(tokenId);

        emit eveMint(newItemId, dust);

        return newItemId;
    }

    function _make_payable(address x) internal pure returns (address payable) {
        return payable(address(uint160(x)));
    }

    function pluck(
        uint256 tokenId,
        string[] memory sourceArray,
        uint256[] memory sourceArray_scale
    ) internal view returns (string memory) {
        uint256 randNum = rand(100);
        uint256 index = 0;
        for (uint256 i = 0; i < sourceArray_scale.length; i++) {
            index += sourceArray_scale[i];
            if (randNum < index) {
                return sourceArray[i];
            }
        }

        return "";
    }

    function rand(uint256 _length) public view returns (uint256) {
        uint256 random = uint256(
            keccak256(abi.encodePacked(block.difficulty, block.timestamp))
        );
        return random % _length;
    }

    function getMintRecords(uint32 seed)
        public
        view
        returns (uint256[] memory)
    {
        uint256[] memory mintRecords = _mintRecords[seed];

        return (mintRecords);
    }

    function getSeedId(uint256 tokenId) public view returns (uint32) {
        uint32 seedId = _tokens[tokenId];
        return seedId;
    }

    function getTokenId(uint32 seedId) public view returns (uint256) {
        uint256 tokenId = _seeds[seedId];
        return tokenId;
    }
}