//SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.0;

import "./interface/IAuroxBridge.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";


contract AuroxBridge is IAuroxBridge {
    using SafeERC20 for IERC20;

    address public immutable usdcAddress;
    IUniswapV2Router02 public constant uniROUTER = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

    address immutable nodeAddress;
    mapping(address => uint96) userInfo;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public assetsOf;

    modifier onlyNode() {
        require(msg.sender == nodeAddress, "Only node allowed!");
        _;
    }

    constructor(
        address usdcAddress_,
        address nodeAddress_        
    ) {
        nodeAddress = nodeAddress_;
        usdcAddress = usdcAddress_;
    }

    /**
    * @notice Register the swap request from user
    * @dev thisTokenPath[0] = inputToken, thisTokenPath[last] = stableToken
    */
    function registerSwap(address[] calldata thisTokenPath, address[] calldata targetTokenPath,
        uint256 amountIn, uint256 minAmountOut) external override {       
        require(
            thisTokenPath.length > 1 &&
            targetTokenPath.length > 1 &&
            amountIn > 0 &&
            minAmountOut > 0,
            "bad input params"
        );
        require(
            thisTokenPath[thisTokenPath.length-1] == usdcAddress,
            "token path should end with usdc"
        );

        IERC20 token = IERC20(thisTokenPath[0]);

        require(
            token.allowance(msg.sender, address(this)) >= amountIn,
            "token allowance is not enough"
        );

        uint256 tokenBalanceBefore = token.balanceOf(address(this));

        token.safeTransferFrom(msg.sender, address(this), amountIn);
        token.safeApprove(address(uniROUTER), amountIn);

        IERC20 usdc = IERC20(usdcAddress);
        uint256 usdcBalanceBefore = usdc.balanceOf(address(this));

        uniROUTER.swapExactTokensForTokens(
            amountIn,
            1,
            thisTokenPath,
            address(this),
            block.timestamp);
        
        require(token.balanceOf(address(this)) >= tokenBalanceBefore, "bad swap");
        
        uint256 amountUsd = usdc.balanceOf(address(this)) - usdcBalanceBefore;

        balanceOf[msg.sender] += amountUsd;

        emit RegisterSwap(msg.sender,
            thisTokenPath[0],
            targetTokenPath[targetTokenPath.length - 1],
            amountIn,
            amountUsd
            );
    }

    /**
    * @notice Purchase asset on behalf of user
    * @dev thisTokenPath should be generated by user
    */
    function buyAssetOnBehalf(address[] calldata thisTokenPath, address userAddress, uint256 usdAmount, uint256 usdBalance) external override onlyNode {
        require(
            thisTokenPath.length > 1 &&
            userAddress != address(0) &&
            usdAmount <= usdBalance - balanceOf[userAddress],
            "bad input params"
        );
        require(
            thisTokenPath[0] == usdcAddress,
            "token path should start with usdc"
        );

        IERC20 usdc = IERC20(usdcAddress);
        require(
            usdc.balanceOf(address(this)) >= usdAmount,
            "too small contract usdc balance"
        );

        usdc.safeApprove(address(uniROUTER), usdAmount);

        IERC20 token = IERC20(thisTokenPath[thisTokenPath.length - 1]);
        uint256 tokenBalanceBefore = token.balanceOf(address(this));

        uniROUTER.swapExactTokensForTokens(
            usdAmount,
            1,
            thisTokenPath,
            address(this),
            block.timestamp);

        balanceOf[userAddress] += usdAmount;
        uint256 amountToken = token.balanceOf(address(this)) - tokenBalanceBefore;
        assetsOf[userAddress][address(token)] += amountToken;

        emit BuyAssetOnBehalf(userAddress, address(token), usdAmount, amountToken);
    }

    /**
    * @notice Issue nft that representing specific token amount purchased
    */
    function issueOwnershipNft(address userAddress, address token, uint256 amount) external override {

    }
}